# Hashing  

## 1Ô∏è‚É£ Introduction  
A **hash function** is a mathematical function that takes an input (any size) and produces a fixed-size output called a **hash**, **digest**, or **fingerprint**.  
Hashing is a **one-way** process ‚Äî it‚Äôs easy to compute a hash from data but infeasible to reconstruct the original data from the hash.

---

## 2Ô∏è‚É£ Why Hashing Matters  
- **Data integrity:** Detects changes in files or messages.  
- **Password security:** Stores password hashes instead of plaintext.  
- **Digital signatures:** Hash data before signing.  
- **Efficient comparison:** Hash values make data lookup faster.  
- **Blockchain:** Links blocks using cryptographic hashes.  

---

## 3Ô∏è‚É£ Hash Function Working  

### Flow  

<img width="704" height="53" alt="image" src="https://github.com/user-attachments/assets/f1aadc8f-1d82-465f-9a49-7e4b6977f79c" />


---

## 4Ô∏è‚É£ Core Properties of Cryptographic Hash Functions  

| Property | Description |
|-----------|-------------|
| **Deterministic** | Same input ‚Üí always same hash. |
| **Preimage Resistance** | Given `h = H(x)`, infeasible to find `x`. (One-way property). |
| **Second Preimage Resistance** | Given `x1`, infeasible to find `x2 ‚â† x1` such that `H(x1) = H(x2)`. |
| **Collision Resistance** | Infeasible to find *any* two distinct inputs producing same hash. |
| **Avalanche Effect** | Small input change ‚Üí drastically different hash. |
| **Efficiency** | Fast to compute for large data. |
| **Fixed Output Size** | Output always a fixed length regardless of input size. |

---

## 5Ô∏è‚É£ Types of Hash Functions  

### üîπ Non-Cryptographic Hashes  
Used for data structures (hash tables), not security:  
- MurmurHash  
- FNV  
- CityHash  

### üîπ Cryptographic Hashes (Security Focused)  
- **MD5** (128-bit, broken ‚Äî use only for non-security purposes)  
- **SHA-1** (160-bit, broken for collisions)  
- **SHA-2 Family:** SHA-224, SHA-256, SHA-384, SHA-512 (widely used)  
- **SHA-3 (Keccak):** New standard, sponge construction  
- **BLAKE2 / BLAKE3:** Fast, secure modern hashes  

---

## 6Ô∏è‚É£ Hashing Algorithms: Construction Styles  

| Construction | Example | How it Works |
|--------------|---------|--------------|
| **Merkle‚ÄìDamg√•rd** | MD5, SHA-1, SHA-2 | Processes input in fixed-size blocks using a compression function. |
| **Sponge Construction** | SHA-3 / Keccak | Absorbs input then squeezes out fixed-size output. |
| **Tree Hashes** | BLAKE3, parallelized SHA | Splits data into chunks, hashes in parallel, combines in a tree. |

---

## 7Ô∏è‚É£ Hash-Based Cryptographic Primitives  

| Primitive | Explanation |
|-----------|-------------|
| **HMAC (Hash-based Message Authentication Code)** | Combines a secret key + hash to authenticate messages. |
| **HKDF (Hash-based Key Derivation Function)** | Derives cryptographic keys from a shared secret. |
| **Digital Signatures** | Data is hashed first, then signature generated on hash. |
| **Commitment Schemes** | Commit to a value while keeping it hidden using a hash. |

---

## 8Ô∏è‚É£ Password Hashing (Important Distinction)  
Plain hash functions alone are **not enough** for passwords.  
Use **specialized password hashing algorithms** designed to be slow & memory-hard:  
- **bcrypt**  
- **scrypt**  
- **Argon2** (modern, NIST-recommended)  

---

## 9Ô∏è‚É£ Real-World Applications of Hashing  

| Area | Use Case |
|-------|----------|
| **Data Integrity** | File verification (SHA-256 checksums). |
| **Digital Signatures** | Hash before signing. |
| **Blockchain / Cryptocurrency** | Linking blocks (Bitcoin uses SHA-256). |
| **Certificates / PKI** | Hashing public keys in X.509 certs. |
| **Message Authentication** | HMAC in TLS, SSH. |

---

## üîü Security Considerations  

- **MD5 & SHA-1 are deprecated** ‚Äî vulnerable to collision attacks.  
- Always use **salt** with password hashing to prevent rainbow table attacks.  
- Use **keyed hashing (HMAC)** for authentication.  
- Pick algorithms with strong **cryptanalysis history** (SHA-2, SHA-3, BLAKE2).
  
### Salt in Hashing   
A **salt** is a random value added to an input **before hashing**.  
It ensures that even if two users have the same password, their hashes are different.  
Salts defend against **rainbow table** and **precomputation attacks**.

##### Salted Hashing Flow  
Password + Random Salt ‚îÄ‚îÄ‚ñ∫ Hash Function ‚îÄ‚îÄ‚ñ∫ Salted Hash
Store: (Salt, Hash)

##### Why Salt is Important  
- Without a salt: Same password ‚Üí same hash.  
- With a salt: Same password ‚Üí different hashes per user.  
---
##### Peppering in Hashing  

While a **salt** is public and stored alongside the hash, a **pepper** is an additional *secret* value mixed into the password **before hashing**. Peppering is used together with salting to further harden password storage.

| Feature | Salt | Pepper |
|----------|------|--------|
| **Purpose** | Prevent rainbow table / precomputation attacks. | Add an extra hidden secret to resist database leaks. |
| **Storage** | Stored with the hash in the database. | Kept secret separately (e.g., in app config, environment variable, or HSM). |
| **Uniqueness** | Unique per user. | Usually one global secret (or per system). |
| **Visibility** | Not secret. | Secret. |

#### Salt + Pepper Flow
Password + Random Salt + Secret Pepper ‚îÄ‚îÄ‚ñ∫ Hash Function ‚îÄ‚îÄ‚ñ∫ Store: (Salt, Hash)

- **Salt** defends against precomputation and ensures uniqueness.  
- **Pepper** adds an *extra secret* that attackers cannot obtain even if they steal the database.

## Visual Overview  

### Hash Function Flow Diagram  
<img width="385" height="331" alt="image" src="https://github.com/user-attachments/assets/2922f0e4-62a4-4073-ac1d-4dc2c48e9d09" />

## Avalanche-Effect
-Input1: "Hello"
-SHA-256: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969

-Input2: "hello"  (changed only 'H'‚Üí'h')
-SHA-256: 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824

## Message Digest, Integrity & Confidentiality

### 1.Message Digest
A **Message Digest** is the fixed-length output of a cryptographic hash function (like **SHA-256**).  
It represents the **fingerprint** of the original message.

- Input: Any length message.
- Output: Fixed-length hash (e.g., 256 bits for SHA-256).
- Purpose: Verify data **integrity** and support **authenticity**.

---

## 2. Integrity vs. Confidentiality

| Property        | What It Means                                                                 |
|-----------------|-------------------------------------------------------------------------------|
| **Integrity**   | -The **hash verifies** the message hasn‚Äôt changed (integrity).          |
| **Confidentiality** | The **encryption hides** the message (confidentiality).                 |

- **Hash/Message Digest alone ‚Üí Integrity.**
- **Encryption (symmetric/asymmetric) ‚Üí Confidentiality.**
- Combine them (encrypt + hash) to get **both**--> HASH.

---

## 3. Sender ‚Üí Receiver Flow with Message Digest (Integrity)
<img width="567" height="637" alt="image" src="https://github.com/user-attachments/assets/d8a65b72-5152-4a62-8127-cf04b4eaaabf" />

## Receiver Side (Confidentiality)
<img width="543" height="716" alt="image" src="https://github.com/user-attachments/assets/aa06719c-2bf7-422d-b596-8d02cd378566" />

-Compare H and H' at Receiver:
  - If equal ‚Üí Integrity OK.
  - If different ‚Üí Message tampered.
